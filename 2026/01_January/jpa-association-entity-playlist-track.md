중간 테이블(연결 엔티티) 패턴: PlaylistTrack 설계 정리
1. 연결 엔티티(PlaylistTrack)의 역할

Playlist 와 Track 은 관계상 “플레이리스트에 여러 트랙이 들어가고, 트랙은 여러 플레이리스트에 담긴다” 형태로 다대다(Many-to-Many) 관계가 성립한다.

하지만 실제 서비스에서는 단순히 “연결됨”만 필요한 게 아니라, 관계 자체에 의미 있는 데이터가 붙는 경우가 많다.
예: 플레이리스트 내 순서, 추가된 시간, 누가 추가했는지, 재생 횟수 등

따라서 다대다를 연결 엔티티로 풀어서:

PlaylistTrack 이 “관계(Association) 그 자체”를 엔티티로 표현

관계에 필요한 부가 속성(메타데이터) 를 안전하게 저장

관계를 CRUD 가능한 독립 모델로 다룸

정리하면 PlaylistTrack의 책임은 다음과 같다.

어떤 플레이리스트에 어떤 트랙이 들어있는지 표현 (playlist_id, track_id)

플레이리스트 내 정렬/순서 같은 관계 속성 관리 (trackOrder)

“추가/삭제/정렬 변경” 같은 관계 조작을 도메인 로직으로 다룰 수 있게 함

2. 단순 Many-to-Many(@ManyToMany)를 피한 이유
(1) 관계에 컬럼이 추가되는 순간 한계

JPA의 @ManyToMany는 기본적으로 중간 테이블을 자동 생성/관리하지만, 그 중간 테이블에 trackOrder 같은 컬럼을 붙이는 순간 관리가 복잡해진다.

중간 테이블이 “엔티티가 아닌 익명 테이블”처럼 동작

trackOrder를 매핑하려면 결국 별도 엔티티로 다시 풀어야 함

즉, 나중에 확장하면 되지 않나? → 확장 시점에 대규모 리팩토링 가능성이 큼

(2) 운영/디버깅/성능 측면의 불리함

다대다에서 예상치 못한 중복 insert, 삭제 전파, 연쇄 업데이트가 발생할 수 있음

연관관계 관리 주체가 모호해지고, SQL이 의도와 다르게 나갈 때 추적이 어렵다

서비스가 커질수록 관계 테이블이 “업무적으로 중요한 테이블”이 되는데, 이를 엔티티로 승격하지 않으면 확장성이 떨어짐

(3) 도메인 모델링 관점

플레이리스트에 트랙이 “속한다”는 관계는 단순 링크가 아니라,
“플레이리스트에 트랙이 특정 순서로 등록된 항목”이라는 도메인 객체로 보는 것이 자연스럽다.

따라서:

PlaylistTrack을 엔티티로 만들면 관계가 1급 시민(First-class)으로 모델링된다.

3. trackOrder 같은 추가 컬럼 처리 방식
핵심 포인트

trackOrder는 Track 자체의 속성이 아니라,
“특정 플레이리스트에서의 트랙의 위치”라는 관계 속성이다.

즉, PlaylistTrack에 들어가는 것이 정확한 모델링이다.

(1) 엔티티 매핑 구조(권장 형태)

PlaylistTrack:

@ManyToOne → Playlist

@ManyToOne → Track

trackOrder (not null)

필요 시 createdAt(추가된 시점) 등 확장 가능

이 구조의 장점:

특정 플레이리스트에서 트랙 순서를 변경하는 기능이 직관적으로 구현됨

“순서 변경”, “중간 삽입”, “삭제 후 재정렬” 같은 비즈니스 로직을 서비스에서 명확히 제어 가능

4. (실무 팁) 제약조건과 정렬 관리
(1) 중복 방지: (playlist_id, track_id) 유니크

같은 트랙이 같은 플레이리스트에 중복으로 들어가는 것을 막고 싶다면:

DB 레벨에서 복합 유니크 제약조건을 거는 것이 가장 확실하다.

애플리케이션에서 체크해도 동시성 상황에서 뚫릴 수 있음

(2) 순서 관리 전략

trackOrder는 다음 중 하나로 운영하는 경우가 많다.

연속 숫자(1,2,3...): 단순하지만 중간 삽입/삭제 시 재정렬 UPDATE가 많이 발생

간격 숫자(10,20,30...): 중간 삽입 시 15 같은 값으로 해결 가능(재정렬 감소)

트래픽이 크면 “정렬 알고리즘(예: fractional indexing)”까지 고려

현재 단계에서는 연속 숫자로 시작해도 충분하고,
추후 요구가 커지면 간격 방식으로 개선하는 접근이 현실적이다.

5. 결론

@ManyToMany는 “관계에 데이터가 붙지 않는 정말 단순한 연결”에서만 제한적으로 적합

PlaylistTrack처럼 관계에 의미가 있고(trackOrder), 기능이 붙는 경우에는
연결 엔티티 패턴이 확장성/유지보수/도메인 모델링 모두에서 유리하다.

trackOrder는 Track의 속성이 아니라 관계의 속성이므로 연결 엔티티에 두는 것이 정석이다.